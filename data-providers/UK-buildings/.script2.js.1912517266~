import { Forma } from "https://esm.sh/forma-embedded-view-sdk/auto";


async function processAndRenderProjectGeojson() {
    try {
        // Fetch the BBox of the terrain
        const projectDetails = await Forma.project.get()
        console.log("projectDetails", projectDetails)
        const bbox = await Forma.terrain.getBbox();
        const adjustbboxArray = adjustBBoxWithRefPoint(bbox, projectDetails.refPoint);
        const bboxWGS84 = convertBBoxToWGS84(adjustbboxArray, projectDetails.projString);
        const landusejson = await fetchLanduseFromOverpassAPI(bboxWGS84);
        console.log("landusejson", landusejson)
        let landuseGeojson = osmtogeojson(landusejson);
        console.log("geojsonOverpass", landuseGeojson)
        const referencePoint = { lat: projectDetails.refPoint[1], long: projectDetails.refPoint[1]}
        const convertedGeojson = recenterGeoJSON(landuseGeojson, referencePoint, 'EPSG:4326', projectDetails.projString)
        console.log("convertedGeojson", convertedGeojson)
        // Adjust the GeoJSON to have the origin at (0,0)
        //const adjustedGeojson = adjustGeojsonOrigin(convertedGeojson);
        //console.log("adjustedGeojson", adjustedGeojson)
        // Placeholder for rendering the GeoJSON
    } catch (error) {
        console.error("Failed to process and render project GeoJSON:", error);
    }
}

function convertBBoxToWGS84(bbox, projString) {
    // Convert each point of the BBox
    const sw = proj4(projString, 'EPSG:4326', [bbox[0], bbox[1]]);
    const ne = proj4(projString, 'EPSG:4326', [bbox[2], bbox[3]]);
    return [sw[0], sw[1], ne[0], ne[1]];
}




function adjustBBoxWithRefPoint(bbox, refPoint, projString) {
    // Assuming bbox is in the project's local UTM coordinates, adjust by refPoint
    const adjustedMinX = bbox.min.x + refPoint[0];
    const adjustedMinY = bbox.min.y + refPoint[1];
    const adjustedMaxX = bbox.max.x + refPoint[0];
    const adjustedMaxY = bbox.max.y + refPoint[1];

    return [adjustedMinX, adjustedMinY, adjustedMaxX, adjustedMaxY];
}

async function fetchLanduseFromOverpassAPI(bboxWGS84) {

    const bboxString = `${bboxWGS84[1]},${bboxWGS84[0]},${bboxWGS84[3]},${bboxWGS84[2]}`;

    // Construct the Overpass query with the correctly formatted bbox string
    const query = `
        [out:json];
        (
          way["landuse"](${bboxString});
          relation["landuse"](${bboxString});
        );
        out body;
        >;
        out skel qt;
      `;

    const overpassUrl = `https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`;

    try {
        const response = await fetch(overpassUrl);
        if (!response.ok) throw new Error('Network response was not ok.');

        const jsonData = await response.json();
        return jsonData;
    } catch (error) {
        console.error('Failed to fetch landuse data from Overpass API:', error);
        throw error; // Rethrow error for further handling
    }
}

function recenterGeoJSON(inputGeoJSON, referencePointUTM, sourceSRID, targetSRID) {
  // Convert the reference point to the target projection
console.log("referencePointUTM", referencePointUTM)
  // Function to project and recenter coordinates
  const transformCoordinates = (coords) => {
    const projectedCoords = proj4(sourceSRID, targetSRID, coords);
    // Subtract the reference point's projected coordinates to recenter
    return proj4(targetSRID, sourceSRID, [
      projectedCoords[0] - referencePointUTM[0],
      projectedCoords[1] - referencePointUTM[1],
    ]);
  };

  // Use turf.js to apply the transformation to every point in the GeoJSON
  turf.coordEach(inputGeoJSON, (currentCoord) => {
    const transformedCoord = transformCoordinates(currentCoord);
    // Directly mutate the coordinates of the input GeoJSON
    currentCoord[0] = transformedCoord[0];
    currentCoord[1] = transformedCoord[1];
  });

  return inputGeoJSON;
}

processAndRenderProjectGeojson();
